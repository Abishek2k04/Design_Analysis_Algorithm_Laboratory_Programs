function floydWarshall(graph, n):
    for k from 0 to n-1:
        for i from 0 to n-1:
            for j from 0 to n-1:
                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

function main():
    Input the number of vertices n
    Create a 2D array graph[n][n]
    Initialize graph[][] with large values (100) for all edges, and 0 for diagonal elements
    Accept input for the weights of edges between vertices from the user
    
    Call floydWarshall(graph, n)
    
    Output the shortest path matrix

main()

#############################################ALGORITHM##################################################################
Sure, here's a non-technical algorithm for the provided program:

1. **Start**
2. **Input the number of vertices**:
   - Ask the user to enter the number of vertices in the graph.
3. **Allocate memory for the graph**:
   - Create a space in the computer's memory to store the graph.
4. **Initialize the graph**:
   - Set up the initial distances between vertices.
   - For each pair of vertices, set the distance to 0 if it's the same vertex (diagonal), and set it to a high value (100) otherwise.
5. **Input the edges**:
   - Ask the user to input the weights of edges between vertices.
6. **Display the original graph**:
   - Show the user the initial state of the graph.
7. **Compute the shortest paths**:
   - Use the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices.
8. **Display the shortest path matrix**:
   - Show the user the shortest distances between all pairs of vertices.
9. **End**

This algorithm outlines the steps of the program in a simple, non-technical manner, focusing on the user's perspective and the high-level actions taken by the program.
